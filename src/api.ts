/**
 * balloon API
 * balloon API
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
export {localVarRequest};
import http = require('http');
import Promise = require('bluebird');

export const specPath = __dirname+'/../swagger.yml';

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if(expectedType)
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* Master node from which the slave is from.
*/
export class ConvertV2SlaveMaster {
    /**
    * The id of the node.
    */
    'id'?: string;
    /**
    * The name of the node.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConvertV2SlaveMaster.attributeTypeMap;
    }
}

/**
* The generated slave node. As long as the slave has not yet been created this is null.
*/
export class ConvertV2SlaveSlave {
    /**
    * The id of the node.
    */
    'id'?: string;
    /**
    * The name of the node.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConvertV2SlaveSlave.attributeTypeMap;
    }
}

/**
* ACL rule.
*/
export class CoreV2AclRule {
    /**
    * The type of the resource.
    */
    'type'?: CoreV2AclRule.TypeEnum;
    /**
    * ACL rules.
    */
    'id'?: string;
    /**
    * Privilege.
    */
    'privilege'?: CoreV2AclRule.PrivilegeEnum;
    'role'?: CoreV2AclRuleRole;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "CoreV2AclRule.TypeEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "privilege",
            "baseName": "privilege",
            "type": "CoreV2AclRule.PrivilegeEnum"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "CoreV2AclRuleRole"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2AclRule.attributeTypeMap;
    }
}

export namespace CoreV2AclRule {
    export enum TypeEnum {
        User = <any> 'user',
        Group = <any> 'group'
    }
    export enum PrivilegeEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
        WP = <any> 'w+',
        D = <any> 'd'
    }
}
/**
* Points to the share owner. If the node is not part of any share this is null.
*/
export class CoreV2AclRuleRole {
    /**
    * The id of the role resource.
    */
    'id'?: string;
    /**
    * The name of role resource.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2AclRuleRole.attributeTypeMap;
    }
}

/**
* Describes the api root.
*/
export class CoreV2ApiRoot {
    'name'?: string;
    'api'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "api",
            "baseName": "api",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2ApiRoot.attributeTypeMap;
    }
}

/**
* Chunking upload session.
*/
export class CoreV2ChunkSession {
    /**
    * The upload session id
    */
    'session'?: string;
    /**
    * Tells how many chunks are left to upload.
    */
    'chunks_left'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "session",
            "baseName": "session",
            "type": "string"
        },
        {
            "name": "chunks_left",
            "baseName": "chunks_left",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2ChunkSession.attributeTypeMap;
    }
}

/**
* The delta is a differential feed to get changes since the last delta call.
*/
export class CoreV2Delta {
    /**
    * If true the client needs to reset its state.
    */
    'reset'?: boolean;
    /**
    * ACL rules.
    */
    'cursor'?: string;
    /**
    * If true the server has more entries and the client must send another request with the latest cursor.
    */
    'has_more'?: boolean;
    'nodes'?: Array<CoreV2Node>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reset",
            "baseName": "reset",
            "type": "boolean"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "has_more",
            "baseName": "has_more",
            "type": "boolean"
        },
        {
            "name": "nodes",
            "baseName": "nodes",
            "type": "Array<CoreV2Node>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Delta.attributeTypeMap;
    }
}

/**
* Event log entry. Each event represents an executed operation on the server.
*/
export class CoreV2EventLog {
    /**
    * The event id.
    */
    'event'?: string;
    /**
    * ISO 8601 timestamp when the event was created.
    */
    'timestamp'?: string;
    /**
    * The event operation.
    */
    'operation'?: CoreV2EventLog.OperationEnum;
    'node'?: CoreV2EventLogNode;
    'parent'?: CoreV2EventLogParent;
    'share'?: CoreV2NodeShare;
    'user'?: CoreV2FileHistoryUser;
    'client'?: CoreV2EventLogClient;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "event",
            "baseName": "event",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "string"
        },
        {
            "name": "operation",
            "baseName": "operation",
            "type": "CoreV2EventLog.OperationEnum"
        },
        {
            "name": "node",
            "baseName": "node",
            "type": "CoreV2EventLogNode"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "CoreV2EventLogParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "CoreV2NodeShare"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "CoreV2FileHistoryUser"
        },
        {
            "name": "client",
            "baseName": "client",
            "type": "CoreV2EventLogClient"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2EventLog.attributeTypeMap;
    }
}

export namespace CoreV2EventLog {
    export enum OperationEnum {
        DeleteCollectionReference = <any> 'deleteCollectionReference',
        DeleteCollectionShare = <any> 'deleteCollectionShare',
        DeleteCollection = <any> 'deleteCollection',
        AddCollection = <any> 'addCollection',
        AddFile = <any> 'addFile',
        AddCollectionShare = <any> 'addCollectionShare',
        AddCollectionReference = <any> 'addCollectionReference',
        UndeleteFile = <any> 'undeleteFile',
        UndeleteCollectionReference = <any> 'undeleteCollectionReference',
        UndeleteCollectionShare = <any> 'undeleteCollectionShare',
        RestoreFile = <any> 'restoreFile',
        RenameFile = <any> 'renameFile',
        RenameCollection = <any> 'renameCollection',
        RenameCollectionShare = <any> 'renameCollectionShare',
        RenameCollectionReference = <any> 'renameCollectionReference',
        CopyFile = <any> 'copyFile',
        CopyCollection = <any> 'copyCollection',
        CopyCollectionShare = <any> 'copyCollectionShare',
        CopyCollectionRFeference = <any> 'copyCollectionRFeference',
        MoveFile = <any> 'moveFile',
        MoveCollection = <any> 'moveCollection',
        MoveCollectionReference = <any> 'moveCollectionReference',
        MoveCollectionShare = <any> 'moveCollectionShare'
    }
}
/**
* Describes the client from which the operation was executed.
*/
export class CoreV2EventLogClient {
    /**
    * The type of the client.
    */
    'type'?: string;
    /**
    * The client app name.
    */
    'app'?: string;
    /**
    * The version of the client app.
    */
    'v'?: string;
    /**
    * The hostname of the client.
    */
    'hostname'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "app",
            "baseName": "app",
            "type": "string"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "string"
        },
        {
            "name": "hostname",
            "baseName": "hostname",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2EventLogClient.attributeTypeMap;
    }
}

/**
* Resolves to the node involved in the operation.
*/
export class CoreV2EventLogNode {
    /**
    * The id of the node
    */
    'id'?: string;
    /**
    * The name of the node
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2EventLogNode.attributeTypeMap;
    }
}

/**
* Points to the parent collection. If the node is in the root this is null.
*/
export class CoreV2EventLogParent {
    /**
    * The id of the parent collection
    */
    'id'?: string;
    /**
    * The name of the parent collection
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2EventLogParent.attributeTypeMap;
    }
}

/**
* File history.
*/
export class CoreV2FileHistory {
    /**
    * The version number.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Type of change.
    */
    'type'?: number;
    'user'?: CoreV2FileHistoryUser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "CoreV2FileHistoryUser"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2FileHistory.attributeTypeMap;
    }
}

/**
* Resolves to user who executed the operation.
*/
export class CoreV2FileHistoryUser {
    /**
    * The id of the share owner.
    */
    'id'?: string;
    /**
    * The username of the share owner.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2FileHistoryUser.attributeTypeMap;
    }
}

/**
* A JSON Patch according rfc6902.
*/
export class CoreV2JsonPatch {
    'op'?: string;
    'path'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2JsonPatch.attributeTypeMap;
    }
}

export class CoreV2Link {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Link.attributeTypeMap;
    }
}

/**
* Contains resource links (URL) to other resources.
*/
export class CoreV2Links {
    'self'?: CoreV2Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "CoreV2Link"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Links.attributeTypeMap;
    }
}

export class CoreV2ListLinks {
    'self'?: CoreV2Link;
    'prev'?: CoreV2Link;
    'next'?: CoreV2Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "CoreV2Link"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "CoreV2Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "CoreV2Link"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2ListLinks.attributeTypeMap;
    }
}

/**
* Node meta data.
*/
export class CoreV2NodeMeta {
    /**
    * Node tags. Tags can be freely choosen.
    */
    'tags'?: Array<string>;
    /**
    * Author.
    */
    'author'?: string;
    /**
    * Content license.
    */
    'license'?: string;
    /**
    * A color tag.
    */
    'color'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "string"
        },
        {
            "name": "license",
            "baseName": "license",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2NodeMeta.attributeTypeMap;
    }
}

/**
* Points to the parent collection. If the nodes is in the root this is null.
*/
export class CoreV2NodeParent {
    /**
    * The id of the parent collection
    */
    'id'?: string;
    /**
    * The name of the parent collection
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2NodeParent.attributeTypeMap;
    }
}

/**
* Points to the shared node (or share reference). If the node is not part of any share this is null.
*/
export class CoreV2NodeShare {
    /**
    * The id of the share collection. If the share is a reference (incoming share) it will point to the share reference and not the id of the shared collection itself.
    */
    'id'?: string;
    /**
    * The name of the share (or share reference).
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2NodeShare.attributeTypeMap;
    }
}

/**
* Points to the share owner. If the node is not part of any share this is null.
*/
export class CoreV2NodeShareowner {
    /**
    * The id of the share owner.
    */
    'id'?: string;
    /**
    * The username of the share owner.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2NodeShareowner.attributeTypeMap;
    }
}

export class CoreV2Resource {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Resource.attributeTypeMap;
    }
}

export class CoreV2ResourceList {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2ResourceList.attributeTypeMap;
    }
}

/**
* Node share.
*/
export class CoreV2Share {
    /**
    * The name of the share. By default the name of the node.
    */
    'share_name'?: string;
    /**
    * ACL rules.
    */
    'acl'?: Array<CoreV2AclRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "share_name",
            "baseName": "share_name",
            "type": "string"
        },
        {
            "name": "acl",
            "baseName": "acl",
            "type": "Array<CoreV2AclRule>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Share.attributeTypeMap;
    }
}

/**
* Request node fiel statistics.
*/
export class CoreV2UserNodeAttributeSummary extends null<String, Array> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CoreV2UserNodeAttributeSummary.attributeTypeMap);
    }
}

/**
* Mail
*/
export class NotificationV2Mail {
    'receiver'?: Array<string>;
    'subject'?: string;
    'body'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "receiver",
            "baseName": "receiver",
            "type": "Array<string>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationV2Mail.attributeTypeMap;
    }
}

/**
* A notification may point to a node. If there is no node given this is null.
*/
export class NotificationV2NotificationNode {
    /**
    * The id of the node.
    */
    'id'?: string;
    /**
    * The name of the node.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationV2NotificationNode.attributeTypeMap;
    }
}

/**
* Points to the message. If there is no sender (For example the message came from the system itself) this is null.
*/
export class NotificationV2NotificationSender {
    /**
    * The id of the sender.
    */
    'id'?: string;
    /**
    * The username of the sender.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationV2NotificationSender.attributeTypeMap;
    }
}

/**
* WOPI document https://wopi.readthedocs.io/projects/wopirest/en/latest/files/CheckFileInfo.html
*/
export class OfficeV2WopiDocument {
    'BaseFileName'?: string;
    'Size'?: string;
    'Version'?: string;
    'OwnerId'?: string;
    'UserId'?: string;
    'UserFriendlyName'?: string;
    'UserCanWrite'?: boolean;
    'PostMessageOrigin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BaseFileName",
            "baseName": "BaseFileName",
            "type": "string"
        },
        {
            "name": "Size",
            "baseName": "Size",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "OwnerId",
            "baseName": "OwnerId",
            "type": "string"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "UserFriendlyName",
            "baseName": "UserFriendlyName",
            "type": "string"
        },
        {
            "name": "UserCanWrite",
            "baseName": "UserCanWrite",
            "type": "boolean"
        },
        {
            "name": "PostMessageOrigin",
            "baseName": "PostMessageOrigin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OfficeV2WopiDocument.attributeTypeMap;
    }
}

/**
* A convert slave
*/
export class ConvertV2Slave {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * Slave format.
    */
    'format'?: string;
    'master'?: ConvertV2SlaveMaster;
    'slave'?: ConvertV2SlaveSlave;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "master",
            "baseName": "master",
            "type": "ConvertV2SlaveMaster"
        },
        {
            "name": "slave",
            "baseName": "slave",
            "type": "ConvertV2SlaveSlave"
        }    ];

    static getAttributeTypeMap() {
        return ConvertV2Slave.attributeTypeMap;
    }
}

/**
* A list of convert slaves.
*/
export class ConvertV2Slaves {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<ConvertV2Slave>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<ConvertV2Slave>"
        }    ];

    static getAttributeTypeMap() {
        return ConvertV2Slaves.attributeTypeMap;
    }
}

/**
* A list of collections.
*/
export class CoreV2Collections {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV2Collection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV2Collection>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Collections.attributeTypeMap;
    }
}

/**
* A list of events.
*/
export class CoreV2EventLogs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV2EventLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV2EventLog>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2EventLogs.attributeTypeMap;
    }
}

/**
* A list of files.
*/
export class CoreV2Files {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV2File>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV2File>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Files.attributeTypeMap;
    }
}

/**
* A group contains user resources.
*/
export class CoreV2Group {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Group name.
    */
    'name'?: string;
    /**
    * User namespace.
    */
    'namespace'?: string;
    /**
    * Array of user id's.
    */
    'member'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Group.attributeTypeMap;
    }
}

/**
* A list of groups.
*/
export class CoreV2Groups {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV2Group>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV2Group>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Groups.attributeTypeMap;
    }
}

/**
* A Node.
*/
export class CoreV2Node {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Node name.
    */
    'name'?: string;
    /**
    * Mimetype.
    */
    'mime'?: string;
    /**
    * Readonly only affects the content of the node but not metadata.
    */
    'readonly'?: boolean;
    /**
    * If node is of type Collection this flag is true.
    */
    'directory'?: boolean;
    'meta'?: CoreV2NodeMeta;
    /**
    * The size in bytes. If the node is of type collection the size is the number of child nodes.
    */
    'size'?: number;
    /**
    * The path abstraction of the node.
    */
    'path'?: string;
    /**
    * Access level.
    */
    'access'?: CoreV2Node.AccessEnum;
    'parent'?: CoreV2NodeParent;
    'share'?: CoreV2NodeShare;
    'shareowner'?: CoreV2NodeShareowner;
    /**
    * Is true if the user has an active subscription on this node.
    */
    'subscription'?: boolean;
    /**
    * Subscription excludes actions from the subscribed user itself.
    */
    'subscription_exclude_me'?: boolean;
    /**
    * Is true if the node has a protected public sharelink.
    */
    'sharelink_has_password'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mime",
            "baseName": "mime",
            "type": "string"
        },
        {
            "name": "readonly",
            "baseName": "readonly",
            "type": "boolean"
        },
        {
            "name": "directory",
            "baseName": "directory",
            "type": "boolean"
        },
        {
            "name": "meta",
            "baseName": "meta",
            "type": "CoreV2NodeMeta"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "access",
            "baseName": "access",
            "type": "CoreV2Node.AccessEnum"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "CoreV2NodeParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "CoreV2NodeShare"
        },
        {
            "name": "shareowner",
            "baseName": "shareowner",
            "type": "CoreV2NodeShareowner"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "boolean"
        },
        {
            "name": "subscription_exclude_me",
            "baseName": "subscription_exclude_me",
            "type": "boolean"
        },
        {
            "name": "sharelink_has_password",
            "baseName": "sharelink_has_password",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Node.attributeTypeMap;
    }
}

export namespace CoreV2Node {
    export enum AccessEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
        WP = <any> 'w+'
    }
}
/**
* A list of nodes.
*/
export class CoreV2Nodes {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV2Node>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV2Node>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Nodes.attributeTypeMap;
    }
}

/**
* A user is used to access the server.
*/
export class CoreV2User {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Unique username.
    */
    'username'?: string;
    /**
    * Display name (Usuallly same as username).
    */
    'name'?: string;
    /**
    * Admin user flag.
    */
    'admin'?: boolean;
    /**
    * User namespace.
    */
    'namespace'?: string;
    /**
    * User locale.
    */
    'locale'?: string;
    /**
    * Authentication source.
    */
    'auth'?: CoreV2User.AuthEnum;
    /**
    * Is true if the user has a local password set.
    */
    'has_password'?: boolean;
    /**
    * Hard quota in bytes (Max. limit of storage usage). Note that external storage is not part of the quota. The default is no limit.
    */
    'hard_quota'?: number;
    /**
    * Soft quota in bytes (Warning of high quota usage). The default is no limit.
    */
    'soft_quota'?: number;
    /**
    * Available storage in bytes. Is -1 if there is no hard_quota.
    */
    'available'?: number;
    /**
    * Used storage in bytes.
    */
    'used'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "CoreV2User.AuthEnum"
        },
        {
            "name": "has_password",
            "baseName": "has_password",
            "type": "boolean"
        },
        {
            "name": "hard_quota",
            "baseName": "hard_quota",
            "type": "number"
        },
        {
            "name": "soft_quota",
            "baseName": "soft_quota",
            "type": "number"
        },
        {
            "name": "available",
            "baseName": "available",
            "type": "number"
        },
        {
            "name": "used",
            "baseName": "used",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2User.attributeTypeMap;
    }
}

export namespace CoreV2User {
    export enum AuthEnum {
        Internal = <any> 'internal',
        External = <any> 'external'
    }
}
/**
* A list of users.
*/
export class CoreV2Users {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<CoreV2User>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<CoreV2User>"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Users.attributeTypeMap;
    }
}

/**
* A notification
*/
export class NotificationV2Notification {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * Notification locale. A locale contains a static message which is of a given locale.
    */
    'locale'?: string;
    /**
    * Subject.
    */
    'subject'?: string;
    /**
    * Message.
    */
    'message'?: string;
    'sender'?: NotificationV2NotificationSender;
    'node'?: NotificationV2NotificationNode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "NotificationV2NotificationSender"
        },
        {
            "name": "node",
            "baseName": "node",
            "type": "NotificationV2NotificationNode"
        }    ];

    static getAttributeTypeMap() {
        return NotificationV2Notification.attributeTypeMap;
    }
}

/**
* A list of notifications.
*/
export class NotificationV2Notifications {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: CoreV2ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<NotificationV2Notification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<NotificationV2Notification>"
        }    ];

    static getAttributeTypeMap() {
        return NotificationV2Notifications.attributeTypeMap;
    }
}

/**
* A collection can hold an unlimited number of child nodes.
*/
export class CoreV2Collection {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Node name.
    */
    'name'?: string;
    /**
    * Mimetype.
    */
    'mime'?: string;
    /**
    * Readonly only affects the content of the node but not metadata.
    */
    'readonly'?: boolean;
    /**
    * If node is of type Collection this flag is true.
    */
    'directory'?: boolean;
    'meta'?: CoreV2NodeMeta;
    /**
    * The size in bytes. If the node is of type collection the size is the number of child nodes.
    */
    'size'?: number;
    /**
    * The path abstraction of the node.
    */
    'path'?: string;
    /**
    * Access level.
    */
    'access'?: CoreV2Collection.AccessEnum;
    'parent'?: CoreV2NodeParent;
    'share'?: CoreV2NodeShare;
    'shareowner'?: CoreV2NodeShareowner;
    /**
    * Is true if the user has an active subscription on this node.
    */
    'subscription'?: boolean;
    /**
    * Subscription excludes actions from the subscribed user itself.
    */
    'subscription_exclude_me'?: boolean;
    /**
    * Is true if the node has a protected public sharelink.
    */
    'sharelink_has_password'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mime",
            "baseName": "mime",
            "type": "string"
        },
        {
            "name": "readonly",
            "baseName": "readonly",
            "type": "boolean"
        },
        {
            "name": "directory",
            "baseName": "directory",
            "type": "boolean"
        },
        {
            "name": "meta",
            "baseName": "meta",
            "type": "CoreV2NodeMeta"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "access",
            "baseName": "access",
            "type": "CoreV2Collection.AccessEnum"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "CoreV2NodeParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "CoreV2NodeShare"
        },
        {
            "name": "shareowner",
            "baseName": "shareowner",
            "type": "CoreV2NodeShareowner"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "boolean"
        },
        {
            "name": "subscription_exclude_me",
            "baseName": "subscription_exclude_me",
            "type": "boolean"
        },
        {
            "name": "sharelink_has_password",
            "baseName": "sharelink_has_password",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2Collection.attributeTypeMap;
    }
}

export namespace CoreV2Collection {
    export enum AccessEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
        WP = <any> 'w+'
    }
}
/**
* A collection can hold an unlimited number of child nodes.
*/
export class CoreV2File {
    '_links'?: CoreV2Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Node name.
    */
    'name'?: string;
    /**
    * Mimetype.
    */
    'mime'?: string;
    /**
    * Readonly only affects the content of the node but not metadata.
    */
    'readonly'?: boolean;
    /**
    * If node is of type Collection this flag is true.
    */
    'directory'?: boolean;
    'meta'?: CoreV2NodeMeta;
    /**
    * The size in bytes. If the node is of type collection the size is the number of child nodes.
    */
    'size'?: number;
    /**
    * The path abstraction of the node.
    */
    'path'?: string;
    /**
    * Access level.
    */
    'access'?: CoreV2File.AccessEnum;
    'parent'?: CoreV2NodeParent;
    'share'?: CoreV2NodeShare;
    'shareowner'?: CoreV2NodeShareowner;
    /**
    * Is true if the user has an active subscription on this node.
    */
    'subscription'?: boolean;
    /**
    * Subscription excludes actions from the subscribed user itself.
    */
    'subscription_exclude_me'?: boolean;
    /**
    * Is true if the node has a protected public sharelink.
    */
    'sharelink_has_password'?: boolean;
    /**
    * The content version. Does increase if the content gets changed.
    */
    'version'?: number;
    /**
    * MD5 content checksum.
    */
    'hash'?: string;
    /**
    * Is true if there is a preview
    */
    'preview'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "CoreV2Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mime",
            "baseName": "mime",
            "type": "string"
        },
        {
            "name": "readonly",
            "baseName": "readonly",
            "type": "boolean"
        },
        {
            "name": "directory",
            "baseName": "directory",
            "type": "boolean"
        },
        {
            "name": "meta",
            "baseName": "meta",
            "type": "CoreV2NodeMeta"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "access",
            "baseName": "access",
            "type": "CoreV2File.AccessEnum"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "CoreV2NodeParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "CoreV2NodeShare"
        },
        {
            "name": "shareowner",
            "baseName": "shareowner",
            "type": "CoreV2NodeShareowner"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "boolean"
        },
        {
            "name": "subscription_exclude_me",
            "baseName": "subscription_exclude_me",
            "type": "boolean"
        },
        {
            "name": "sharelink_has_password",
            "baseName": "sharelink_has_password",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "preview",
            "baseName": "preview",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CoreV2File.attributeTypeMap;
    }
}

export namespace CoreV2File {
    export enum AccessEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
        WP = <any> 'w+'
    }
}

let enumsMap: {[index: string]: any} = {
        "CoreV2AclRule.TypeEnum": CoreV2AclRule.TypeEnum,
        "CoreV2AclRule.PrivilegeEnum": CoreV2AclRule.PrivilegeEnum,
        "CoreV2EventLog.OperationEnum": CoreV2EventLog.OperationEnum,
        "CoreV2Node.AccessEnum": CoreV2Node.AccessEnum,
        "CoreV2User.AuthEnum": CoreV2User.AuthEnum,
        "CoreV2Collection.AccessEnum": CoreV2Collection.AccessEnum,
        "CoreV2File.AccessEnum": CoreV2File.AccessEnum,
}

let typeMap: {[index: string]: any} = {
    "ConvertV2SlaveMaster": ConvertV2SlaveMaster,
    "ConvertV2SlaveSlave": ConvertV2SlaveSlave,
    "CoreV2AclRule": CoreV2AclRule,
    "CoreV2AclRuleRole": CoreV2AclRuleRole,
    "CoreV2ApiRoot": CoreV2ApiRoot,
    "CoreV2ChunkSession": CoreV2ChunkSession,
    "CoreV2Delta": CoreV2Delta,
    "CoreV2EventLog": CoreV2EventLog,
    "CoreV2EventLogClient": CoreV2EventLogClient,
    "CoreV2EventLogNode": CoreV2EventLogNode,
    "CoreV2EventLogParent": CoreV2EventLogParent,
    "CoreV2FileHistory": CoreV2FileHistory,
    "CoreV2FileHistoryUser": CoreV2FileHistoryUser,
    "CoreV2JsonPatch": CoreV2JsonPatch,
    "CoreV2Link": CoreV2Link,
    "CoreV2Links": CoreV2Links,
    "CoreV2ListLinks": CoreV2ListLinks,
    "CoreV2NodeMeta": CoreV2NodeMeta,
    "CoreV2NodeParent": CoreV2NodeParent,
    "CoreV2NodeShare": CoreV2NodeShare,
    "CoreV2NodeShareowner": CoreV2NodeShareowner,
    "CoreV2Resource": CoreV2Resource,
    "CoreV2ResourceList": CoreV2ResourceList,
    "CoreV2Share": CoreV2Share,
    "CoreV2UserNodeAttributeSummary": CoreV2UserNodeAttributeSummary,
    "NotificationV2Mail": NotificationV2Mail,
    "NotificationV2NotificationNode": NotificationV2NotificationNode,
    "NotificationV2NotificationSender": NotificationV2NotificationSender,
    "OfficeV2WopiDocument": OfficeV2WopiDocument,
    "ConvertV2Slave": ConvertV2Slave,
    "ConvertV2Slaves": ConvertV2Slaves,
    "CoreV2Collections": CoreV2Collections,
    "CoreV2EventLogs": CoreV2EventLogs,
    "CoreV2Files": CoreV2Files,
    "CoreV2Group": CoreV2Group,
    "CoreV2Groups": CoreV2Groups,
    "CoreV2Node": CoreV2Node,
    "CoreV2Nodes": CoreV2Nodes,
    "CoreV2User": CoreV2User,
    "CoreV2Users": CoreV2Users,
    "NotificationV2Notification": NotificationV2Notification,
    "NotificationV2Notifications": NotificationV2Notifications,
    "CoreV2Collection": CoreV2Collection,
    "CoreV2File": CoreV2File,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum BallonAppElasticsearchV2ApiApiKeys {
}

export class BallonAppElasticsearchV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BallonAppElasticsearchV2ApiApiKeys, value: string) {
        (this.authentications as any)[BallonAppElasticsearchV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Extended search query using elasticsearch
     * @param query Elasticsearch query as JSON
     * @param deleted Wherever include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted.
     */
    public queryElasticsearch (query: string, deleted?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling queryElasticsearch.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Nodes";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConvertV2ApiApiKeys {
}

export class ConvertV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConvertV2ApiApiKeys, value: string) {
        (this.authentications as any)[ConvertV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add new convert slave
     * @param file File identifier
     * @param body Add new conversion slave 
     */
    public addSlave (file: string, body: ConvertV2Slave) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling addSlave.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addSlave.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ConvertV2Slave")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "ConvertV2Slave";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ConvertV2Slave;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConvertV2Slave");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete slave
     * @param file File identifier
     * @param slave Slave identifier
     */
    public deleteSlave (file: string, slave: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves/{slave}'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)))
            .replace('{' + 'slave' + '}', encodeURIComponent(String(slave)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling deleteSlave.');
        }

        // verify required parameter 'slave' is not null or undefined
        if (slave === null || slave === undefined) {
            throw new Error('Required parameter slave was null or undefined when calling deleteSlave.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single slave
     * @param file File identifier
     * @param slave Slave identifier
     */
    public getSlave (file: string, slave: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves/{slave}'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)))
            .replace('{' + 'slave' + '}', encodeURIComponent(String(slave)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getSlave.');
        }

        // verify required parameter 'slave' is not null or undefined
        if (slave === null || slave === undefined) {
            throw new Error('Required parameter slave was null or undefined when calling getSlave.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "ConvertV2Slave";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ConvertV2Slave;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConvertV2Slave");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get existing convert slaves
     * @param file File identifier
     */
    public getSlaves (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getSlaves.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "ConvertV2Slaves";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ConvertV2Slaves;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConvertV2Slaves");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get supported file formats to convert to (formats do vary between files)
     * @param file File identifier
     */
    public getSupportedFormats (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/supported-formats'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getSupportedFormats.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "Array<string>";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CoreV2ApiApiKeys {
}

export class CoreV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CoreV2ApiApiKeys, value: string) {
        (this.authentications as any)[CoreV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add new group
     * @param data 
     */
    public addGroup (data?: CoreV2Group) : any {
        const localVarPath = this.basePath + '/api/v2/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV2Group")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Group";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add new user
     * @param data 
     */
    public addUser (data?: CoreV2User) : any {
        const localVarPath = this.basePath + '/api/v2/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "CoreV2User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2User";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clone existing node
     * @param node Node identifier
     * @param destid Destination collection, if this is null root is taken
     * @param conflict Conflict resolution
     */
    public cloneNode (node: string, destid?: string, conflict?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/clone'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling cloneNode.');
        }

        if (destid !== undefined) {
            localVarQueryParameters['destid'] = ObjectSerializer.serialize(destid, "string");
        }

        if (conflict !== undefined) {
            localVarQueryParameters['conflict'] = ObjectSerializer.serialize(conflict, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Node";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new collection
     * @param collection Parent collection
     * @param body 
     */
    public createCollection (collection: string, body: CoreV2Collection) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling createCollection.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CoreV2Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Collection";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new collection in root
     * @param collection Parent collection
     * @param body 
     */
    public createRootCollection (collection: string, body: CoreV2Collection) : any {
        const localVarPath = this.basePath + '/api/v2/collections'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling createRootCollection.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createRootCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CoreV2Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Collection";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete group
     * @param group Resource identifier
     * @param force Per default the group gets disabled, if force is set the group gets removed completely.
     */
    public deleteGroup (group: string, force?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling deleteGroup.');
        }

        if (force !== undefined) {
            localVarQueryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete node
     * @param node Node identifier
     * @param force Force flag need to be set to delete a node from trash (node must have the deleted flag) 
     * @param ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely 
     * @param at Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly
     */
    public deleteNode (node: string, force?: boolean, ignore_flag?: boolean, at?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling deleteNode.');
        }

        if (force !== undefined) {
            localVarQueryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }

        if (ignore_flag !== undefined) {
            localVarQueryParameters['ignore_flag'] = ObjectSerializer.serialize(ignore_flag, "boolean");
        }

        if (at !== undefined) {
            localVarQueryParameters['at'] = ObjectSerializer.serialize(at, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     * @param collection Collection identifier
     */
    public deleteShare (collection: string) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/share'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteShare.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete user
     * @param user Resource identifier
     * @param force Per default the user gets disabled, if force is set the user gets removed completely.
     */
    public deleteUser (user: string, force?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteUser.');
        }

        if (force !== undefined) {
            localVarQueryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get server status
     */
    public getApi () : any {
        const localVarPath = this.basePath + '/api';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2ApiRoot";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2ApiRoot;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2ApiRoot");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all children of a collection
     * @param collection Parent collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param deleted Wheter to include deleted or not
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param recursive Include children recursively.
     */
    public getChildren (collection: string, query?: string, deleted?: number, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, recursive?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/children'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getChildren.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Nodes";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all collections
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param deleted Wheter to include deleted or not
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getCollections (query?: string, deleted?: number, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/collections';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Collections";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Collections;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Collections");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download node contents. Note that collections are zipped on-the-fly.
     * @param node Node identifier
     * @param Byte_Ranges Read stream from a specific offset/limit in bytes 
     * @param encode Can be set to base64 to encode content as base64.
     * @param download Force download file (Content-Disposition: attachment HTTP header)
     */
    public getContent (node: string, Byte_Ranges?: number, encode?: 'base64', download?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/content'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getContent.');
        }

        if (encode !== undefined) {
            localVarQueryParameters['encode'] = ObjectSerializer.serialize(encode, "'base64'");
        }

        if (download !== undefined) {
            localVarQueryParameters['download'] = ObjectSerializer.serialize(download, "boolean");
        }

        localVarHeaderParams['Byte-Ranges'] = ObjectSerializer.serialize(Byte_Ranges, "number");

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "Buffer";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user object of the current authenticated user
     * @param attributes Filter attributes
     */
    public getCurrentUser (attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/users/whoami';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2User";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return delete nodes (Excluding sub nodes of deleted collections)
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getDeletedNodes (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/trash';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Nodes";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delta stream with cursor support.
     * @param limit Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often 
     * @param attributes Filter attributes, per default not all attributes would be returned
     * @param cursor Set a cursor to rquest next nodes within delta processing 
     */
    public getDelta (limit?: number, attributes?: Array<string>, cursor?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/delta';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Delta";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Delta;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Delta");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event log containing all operations which are made by the user himself or share members
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getEventLog (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/event-log';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2EventLogs";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2EventLogs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2EventLogs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a full change history of a file
     * @param file File identifier
     */
    public getFileHistory (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/history'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getFileHistory.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2FileHistory";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2FileHistory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2FileHistory");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all files
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param deleted Wheter to include deleted or not
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getFiles (query?: string, deleted?: number, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/files';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Files";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Files;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Files");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single group
     * @param group Resource identifier
     * @param attributes Filter attributes
     */
    public getGroup (group: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroup.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Group";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request all member of a group
     * @param group Resource identifier
     */
    public getGroupMembers (group: string) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}/members'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupMembers.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "Array<CoreV2User>";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Array<CoreV2User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CoreV2User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A group is a colletion of users
     * @summary Get groups
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getGroups (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Groups";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Groups;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Groups");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     */
    public getLastCursor () : any {
        const localVarPath = this.basePath + '/api/v2/nodes/last-cursor';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "string";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single node
     * @param node Node identifier
     * @param attributes Filter attributes
     */
    public getNode (node: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getNode.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Node";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get summary of node usage.
     * @param user Resource identifier
     */
    public getNodeAttributeSummary (user: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/node-attribute-summary'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getNodeAttributeSummary.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2UserNodeAttributeSummary";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2UserNodeAttributeSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2UserNodeAttributeSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event log containing all operations which are made by the user himself or share members on a given node
     * @param node Node identifier
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getNodeEventLog (node: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/event-log'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getNodeEventLog.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2EventLogs";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2EventLogs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2EventLogs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all nodes
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param deleted Wheter to include deleted or not
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getNodes (query?: string, deleted?: number, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Nodes";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     * @param node Node identifier
     * @param attributes Filter attributes
     * @param self Include requested collection itself at the end of the list (Will be ignored if the requested node is a file)
     */
    public getParentNodes (node: string, attributes?: Array<string>, self?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/parents'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getParentNodes.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (self !== undefined) {
            localVarQueryParameters['self'] = ObjectSerializer.serialize(self, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Nodes";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all children of the root collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param deleted Wheter to include deleted or not
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param recursive Include children recursively.
     */
    public getRootChildren (query?: string, deleted?: number, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, recursive?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/collections/children';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Nodes";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get share acl and share name
     * @param collection Collection identifier
     */
    public getShare (collection: string) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/share'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getShare.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Share";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Share;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Share");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single user
     * @param user Resource identifier
     * @param attributes Filter attributes
     */
    public getUser (user: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUser.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2User";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user avatar
     * @param user Resource identifier
     */
    public getUserAvatar (user: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/avatar'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserAvatar.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2User";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request all groups of a user
     * @param user Resource identifier
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getUserGroups (user: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/groups'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserGroups.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Groups";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Groups;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Groups");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A user is a colletion of users
     * @summary Get users
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getUsers (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "Array<CoreV2Users>";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Array<CoreV2Users>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CoreV2Users>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get server status
     */
    public getV2 () : any {
        const localVarPath = this.basePath + '/api/v2';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2ApiRoot";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2ApiRoot;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2ApiRoot");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Move node (Change parent collection), single or multiple ones
     * @param node Node identifier
     * @param destid Destination collection, if this is null root is taken
     * @param conflict Conflict resolution
     */
    public moveNode (node: string, destid?: string, conflict?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/move'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling moveNode.');
        }

        if (destid !== undefined) {
            localVarQueryParameters['destid'] = ObjectSerializer.serialize(destid, "string");
        }

        if (conflict !== undefined) {
            localVarQueryParameters['conflict'] = ObjectSerializer.serialize(conflict, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Node";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set attributes for group
     * @param group Resource identifier
     * @param body Set attributes for group
     */
    public patchGroup (group: string, body: CoreV2Group) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchGroup.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CoreV2Group")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Group";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set attributes for user
     * @param user Resource identifier
     * @param body Set attributes for user
     */
    public patchUser (user: string, body: CoreV2User) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling patchUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CoreV2User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2User";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rollback to a recent version from history. Use the version number from history.
     * @param file File identifier
     */
    public rollbackFile (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/restore'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling rollbackFile.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2File";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2File;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2File");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new share from an existing collection
     * @param collection Collection identifier
     * @param body Create a new share from an existing collection 
     */
    public shareCollection (collection: string, body: CoreV2Share) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/share'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling shareCollection.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling shareCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CoreV2Share")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Collection";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Restore deleted group
     * @param group Resource identifier
     */
    public undeleteGroup (group: string) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}/undelete'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling undeleteGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Group";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Undelete (Restore from trash) a single node or multiple ones.
     * @param node Node identifier
     * @param move If node should also be moved during undelete
     * @param destid If node should also be moved during undelete
     * @param conflict Conflict resolution
     */
    public undeleteNode (node: string, move?: boolean, destid?: string, conflict?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/undelete'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling undeleteNode.');
        }

        if (move !== undefined) {
            localVarQueryParameters['move'] = ObjectSerializer.serialize(move, "boolean");
        }

        if (destid !== undefined) {
            localVarQueryParameters['destid'] = ObjectSerializer.serialize(destid, "string");
        }

        if (conflict !== undefined) {
            localVarQueryParameters['conflict'] = ObjectSerializer.serialize(conflict, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Node";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Restore deleted user
     * @param user Resource identifier
     */
    public undeleteUser (user: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/undelete'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling undeleteUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2User";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change attributes
     * @param node Node identifier
     * @param body Change attributes 
     */
    public updateNode (node: string, body: CoreV2Node) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling updateNode.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateNode.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CoreV2Node")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Node";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     * @param body File content
     */
    public uploadChunk (body: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/chunk';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling uploadChunk.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2File";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2File;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2File");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     * @param body File content
     */
    public uploadFile (body?: string) : any {
        const localVarPath = this.basePath + '/api/v2/files';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2File";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2File;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2File");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DesktopclientV2ApiApiKeys {
}

export class DesktopclientV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DesktopclientV2ApiApiKeys, value: string) {
        (this.authentications as any)[DesktopclientV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Download balloon desktop client
     * @param format Request client foramt (deb, rpm, exe, pkg, zip or a custom format)
     */
    public getDesktopClient (format: 'deb' | 'rpm' | 'exe' | 'pkg' | 'zip') : any {
        const localVarPath = this.basePath + '/api/v2/desktop-clients/{format}/content'
            .replace('{' + 'format' + '}', encodeURIComponent(String(format)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'format' is not null or undefined
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getDesktopClient.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "Buffer";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NotificationV2ApiApiKeys {
}

export class NotificationV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NotificationV2ApiApiKeys, value: string) {
        (this.authentications as any)[NotificationV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a notification
     * @param notification Resource identifier
     */
    public deleteNotification (notification: string) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/{notification}'
            .replace('{' + 'notification' + '}', encodeURIComponent(String(notification)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling deleteNotification.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get my nofitifications
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getMyNotifications (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "NotificationV2Notifications";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: NotificationV2Notifications;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NotificationV2Notifications");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single notification
     * @param notification Resource identifier
     */
    public getNotification (notification: string) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/{notification}'
            .replace('{' + 'notification' + '}', encodeURIComponent(String(notification)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling getNotification.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "NotificationV2Notification";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: NotificationV2Notification;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NotificationV2Notification");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send notification
     * @param body 
     */
    public postNotification (body?: NotificationV2Notification) : any {
        const localVarPath = this.basePath + '/api/v2/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "NotificationV2Notification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "NotificationV2Notification";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: NotificationV2Notification;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NotificationV2Notification");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send notification to all users
     * @param body Notification
     */
    public sendBroadcast (body?: NotificationV2Notification) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/broadcast';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "NotificationV2Notification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "NotificationV2Notification";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: NotificationV2Notification;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NotificationV2Notification");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send mail
     * @param body Mail
     */
    public sendMail (body?: NotificationV2Mail) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/mail';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "NotificationV2Mail")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Receive node updates
     * @param node Node identifier
     * @param subscribe If true the subscription is active
     * @param exclude_me Exclude subscription owner (me) from change notifications
     * @param recursive Apply subscription to children (inclusive newly added children)
     */
    public subscribeNode (node: string, subscribe?: boolean, exclude_me?: boolean, recursive?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/subscription'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling subscribeNode.');
        }

        if (subscribe !== undefined) {
            localVarQueryParameters['subscribe'] = ObjectSerializer.serialize(subscribe, "boolean");
        }

        if (exclude_me !== undefined) {
            localVarQueryParameters['exclude_me'] = ObjectSerializer.serialize(exclude_me, "boolean");
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Node";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PreviewV2ApiApiKeys {
}

export class PreviewV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PreviewV2ApiApiKeys, value: string) {
        (this.authentications as any)[PreviewV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a preview of the files content. The body either contains an encoded string or a jpeg binary.
     * @param file File identifier
     * @param encode Set to base64 to return a jpeg encoded preview as base64, else return it as jpeg binary
     */
    public getPreview (file: string, encode?: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/preview'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getPreview.');
        }

        if (encode !== undefined) {
            localVarQueryParameters['encode'] = ObjectSerializer.serialize(encode, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SharelinkV2ApiApiKeys {
}

export class SharelinkV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SharelinkV2ApiApiKeys, value: string) {
        (this.authentications as any)[SharelinkV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a unique sharing link of a node (global accessible): a possible existing link will be deleted if this method will be called.
     * @param node Node identifier
     * @param expiration Expire timestamp as unix timestap. Tells the server when the public link should expire automatically. The default is to never expire.
     * @param password Optionally set a password to protect the public link.
     */
    public createLink (node: string, expiration?: number, password?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/share-link'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling createLink.');
        }

        if (expiration !== undefined) {
            localVarQueryParameters['expiration'] = ObjectSerializer.serialize(expiration, "number");
        }

        if (password !== undefined) {
            localVarQueryParameters['password'] = ObjectSerializer.serialize(password, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2Node";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing sharing link
     * @param node Node identifier
     */
    public deleteLink (node: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/share-link'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling deleteLink.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WopiV2ApiApiKeys {
}

export class WopiV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WopiV2ApiApiKeys, value: string) {
        (this.authentications as any)[WopiV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create new document from an existing office document template
     * @param body 
     */
    public createDocument (body: CoreV2File) : any {
        const localVarPath = this.basePath + '/api/v2/office/documents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CoreV2File")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "CoreV2File";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: CoreV2File;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CoreV2File");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get document session information including document owner, session user and document size
     * @param document The document id
     * @param access_token An access token to access the document
     */
    public getWopiDocument (document: string, access_token: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/wopi/document/{document}';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'document' is not null or undefined
        if (document === null || document === undefined) {
            throw new Error('Required parameter document was null or undefined when calling getWopiDocument.');
        }

        // verify required parameter 'access_token' is not null or undefined
        if (access_token === null || access_token === undefined) {
            throw new Error('Required parameter access_token was null or undefined when calling getWopiDocument.');
        }

        if (document !== undefined) {
            localVarQueryParameters['document'] = ObjectSerializer.serialize(document, "string");
        }

        if (access_token !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(access_token, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "OfficeV2WopiDocument";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: OfficeV2WopiDocument;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OfficeV2WopiDocument");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get document contents
     * @param document The document id 
     * @param access_token An access token to access the document
     */
    public getWopiDocumentContent (document: string, access_token: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/wopi/document/{document}/contents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'document' is not null or undefined
        if (document === null || document === undefined) {
            throw new Error('Required parameter document was null or undefined when calling getWopiDocumentContent.');
        }

        // verify required parameter 'access_token' is not null or undefined
        if (access_token === null || access_token === undefined) {
            throw new Error('Required parameter access_token was null or undefined when calling getWopiDocumentContent.');
        }

        if (document !== undefined) {
            localVarQueryParameters['document'] = ObjectSerializer.serialize(document, "string");
        }

        if (access_token !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(access_token, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Save document contents
     * @param document The document id 
     * @param access_token An access token to access the document
     * @param body Document content
     */
    public updateWopiDocuemntContent (document: string, access_token: string, body?: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/wopi/document/{document}/contents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'document' is not null or undefined
        if (document === null || document === undefined) {
            throw new Error('Required parameter document was null or undefined when calling updateWopiDocuemntContent.');
        }

        // verify required parameter 'access_token' is not null or undefined
        if (access_token === null || access_token === undefined) {
            throw new Error('Required parameter access_token was null or undefined when calling updateWopiDocuemntContent.');
        }

        if (document !== undefined) {
            localVarQueryParameters['document'] = ObjectSerializer.serialize(document, "string");
        }

        if (access_token !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(access_token, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        var returnType = "";
        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true || returnType === "Buffer") {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
